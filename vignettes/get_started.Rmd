---
title: "Get Started"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Get Started}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# cevodata

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

The main data structure used by cevomod is the S3 class cevodata. The easiest way to prepare the object is to create an empty object using the `init_cevodata()` constructor and populate it with data using the `add_*_data()` methods.

Let's use the list of SNV variants and the metadata from the small attached artificial dataset `test_data`

```{r setup}
suppressPackageStartupMessages({
  library(cevomod)
  library(tidyverse)
})

snvs <- SNVs(test_data)
sample_data <- test_data$metadata
```

```{r}
snvs
```

```{r}
sample_data
```

Most of the cevomod functions are pipe-oriented, so we can create and populate the object through the small pipeline:

```{r}
cd <- init_cevodata(name = "Demo data") |> 
  add_SNV_data(snvs, name = "snvs") |> 
  add_sample_data(sample_data)

cd
```

`name` can be any string that is informative for the user.


# VAF spectra

cevomod models are fitted to the Variant Allele Frequency Spectra of the samples. Spectra can be displayed with the `plot_SFS()` function (SFS - *Site Frequency Spectrum*). Most of the cevomod plotting functions return a ggplot object which can be easily modified. Additional aesthetics can be added with the `aes()` function. Since the `metadata` is left-joined to the plot data, the metadata columns can be directly used in the `eas()` call. 

```{r}
plot_SFS(cd) +
  aes(fill = sex) +
  scale_fill_manual(values = c(male = "#DD4124", female = "#00496F")) +
  labs(title = "Variant Allele Frequency Spectrum")
```


# Preparation

Before fitting the models, we need to run the `prepare_SNVs()` function. This step binarizes the VAF values and adds the column `f_interval`. By default, the number of bins is equal to the median sequencing coverage of the variants in the sample. This allows to reduce aliasing noise in samples with low sequencing depth and to analyze samples with higher coverage with higher resolution. The desired number of bins can also be specified manually using the `bins` argument.

```{r}
cd <- cd |> 
  prepare_SNVs()

SNVs(cd) |> 
  glimpse()
```

# Model fitting

Once the SNVs are prepared, the models can be fitted using the `fit_*()` functions. Full models consist of the power-law component and one or more binomial components, which are fitted sequentially.

In this example, we first fit the power-law model with an exponent of 2, and then the mixture of binomial models.

```{r}
cd <- cd |> 
  fit_powerlaw_tail_fixed() |> 
  fit_subclones()
```


```{r}
cd
```

The fitted models can be listed with:

```{r}
get_model_names(cd)
```

and the last fitted model is the active one:

```{r}
active_models(cd)
```

Models can be viewed with the `get_models()` function:

```{r}
get_models(cd, which = "powerlaw_fixed")
```

The active model is returned if the `which` argument is left empty:

```{r}
get_models(cd)
```

The tibble lists the components for all models and samples. Binomial components are called either the clones or the subclones. The component with the highest cellular frequency is called the clone, and the remaining components are called subclones. This distinction is important when estimating the subclonal evolutionary parameters: the main clones are not under positive selection in the tumor, so we only estimate the evolutionary parameters for the subclones.



# Plot models

The fitted models can be visualized with the `plot_models()` function:

```{r}
plot_models(cd) +
  aes(fill = sex) +
  scale_fill_manual(values = c(male = "#DD4124", female = "#00496F")) +
  labs(title = "Variant Allele Frequency Spectrum")
```

The model fitted to sample 2 is very inaccurate. The slope of the distribution is too steep to be approximated by the power-law exponent of 2. This sample should not be fitted with the model with the fixed power-law component. We will ignore this fit when estimating the evolutionary parameters.



# Evolutionary parameters

The evolutionary parameters for the subclones can be calculated using the equations provided by [Williams et al. (2018)](https://doi.org/10.1038/s41588-018-0128-6). Williams assumes an exponential tumor growth and a constant mutation rate, under which the power-law exponent equals 2, so we can use the equations with the models we fitted. In cevomod, we use the code and functions implemented in the [MOBSTER package](https://github.com/caravagnalab/mobster/blob/master/R/evodynamics.R) to calculate the parameters. We should not use the model for Sample 2, though. The mutation rate is severely underestimated, and the model fit is inaccurate. One should evaluate the fitted models carefully, before continuing with the analysis.

Mutation rates can be obtained with `get_mutation_rates()`, and the selection coefficients with `get_selection_coefficients()` functions. Both functions can be run on the cevodata objects (with the correct models fitted), or on the model tibbles directly. This allows us to manually correct the model tibbles before the calculation of the evolutionary parameters.

For example, one can get filter Sample 2 out from the cevodata object:

```{r}
cd |> 
  filter(sample_id != "Sample 2") |> 
  get_models() |> 
  get_mutation_rates()
```

or from the models tibble:


```{r}
cd |> 
  get_models() |> 
  filter(sample_id != "Sample 2") |> 
  get_selection_coefficients()
```


